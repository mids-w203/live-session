mod_5_ci
mod_6 <- d[ , lm(avg_bins_treat ~ bin + sms + base_avg_bins_treat +
no_cellphone + street_factor)]
mod_6_ci <- coefci(
x     = mod_6,
parm  = 'bin',
level = 0.95,
vcov. = vcovHC
)
mod_6_ci
mod_6
d[ , either_sms_or_bin := bin + sms > 0]
d[ , either_sms_or_bin := bin + sms > 0]
mod_6_f_test <- d[ , lm(avg_bins_treat ~ either_sms_or_bin + base_avg_bins_treat +
no_cellphone + street_factor)]
anova(mod_6, mod_6_f_test, test = "F")
summary(mod_6_f_test)
mod_6_ci
mod_6_ci <- coefci(
x     = mod_6,
parm  = c('bin', 'sms'),
level = 0.95,
vcov. = vcovHC
)
mod_6_ci
mod_6_interaction <- d[ , lm(avg_bins_treat ~ bin * sms + base_avg_bins_treat +
no_cellphone + street_factor)]
summary(mod_6_interaction)
model_alpha <- d[ , lm(avg_bins_treat ~ bin + factor(street))]
summary(model_alpha)
model_alpha <- d[ , lm(avg_bins_treat ~ bin + factor(street))]
model_alpha_go <- d[ , lm(avg_bins_treat ~ bin)]
anova(model_alpha, model_alpha_go, test = 'F')
model_beta_go <- d[ , lm(avg_bins_treat ~ bin + base_avg_bins_treat)]
model_beta <- d[ , lm(avg_bins_treat ~ bin + base_avg_bins_treat + factor(street))]
anova(model_beta_go, model_beta)
anova(model_beta_go, model_beta, test = 'F')
model_alpha <- d[ , lm(avg_bins_treat ~ bin + factor(street))]
model_alpha_go <- d[ , lm(avg_bins_treat ~ bin)]
anova(model_alpha, model_alpha_go, test = 'F')
model_beta_go <- d[ , lm(avg_bins_treat ~ bin + base_avg_bins_treat)]
model_beta <- d[ , lm(avg_bins_treat ~ bin + base_avg_bins_treat + factor(street))]
anova(model_beta_go, model_beta, test = 'F')
d[ , street_average     := mean(avg_bins_treat), by = .(street)]
d[ , pre_street_average := mean(base_avg_bins_treat), by = .(street)]
model_zeta <- d[ , lm(avg_bins_treat ~ bin + street_average)]
model_zeta <- d[ , lm(avg_bins_treat ~ bin + base_avg_bins_treat + street_average)]
anova(model_zeta, model_beta, test = "F")
model_zeus <- d[ , lm(avg_bins_treat ~ bin + base_avg_bins_treat + pre_street_average)]
summary(model_zeus)
d <- haven::read_dta(file = './karlan_data/analysis_dataallcountries.dta')
glimpse(d)
library(dplyr)
library(broom)
library(ggplot2)
library(patchwork)
library(sandwich)
library(lmtest)
create_homoskedastic_data <- function(n = 100) {
d <- data.frame(id = 1:n) %>%
mutate(
x1 = runif(n=n, min=0, max=10),
x2 = rnorm(n=n, mean=10, sd=2),
x3 = rnorm(n=n, mean=0, sd=2),
y  = .5 + 1*x1 + 2*x2 + .25*x3^2 + rnorm(n=n, mean=0, sd=1)
)
return(d)
}
d <- create_homoskedastic_data(n=100)
outcome_histogram <- d %>%
ggplot() + # fill in the rest of this chunk to create a plot
aes(x = y) +
geom_histogram(bins = 20) +
labs(
x = "Outcome Values",
title = "Histogram of Outcomes",
subtitle = "It looks like the CLT should work."
)
outcome_histogram
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + X3, data = d)
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + x3, data = d)
model_3 <- lm(y ~ x1 + x2 + I(x3^2), data = d)
model_4 <- lm(y ~ x1 + x2 + x2 + I(x3^2), data = d)
model_5 <- lm(Y ~ x1 + x2 + x3^2, data =d)
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + x3, data = d)
model_3 <- lm(y ~ x1 + x2 + I(x3^2), data = d)
model_4 <- lm(y ~ x1 + x2 + x2 + I(x3^2), data = d)
model_5 <- lm(y ~ x1 + x2 + x3^2, data =d)
anova(model_5, model_3)
summary(model_3)
summary(model_3)
summary(model_5)
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + x3, data = d)
model_3 <- lm(y ~ x1 + x2 + I(x3^2), data = d)
model_4 <- lm(y ~ x1 + x2 + x2 + I(x3^2), data = d)
calculate_msr <- function(model) {
# This function takes a model, and uses the `resid` function
# together with the definition of the msr to produce
# the MEAN of the squared residuals
msr <- mean(resid(model)^2)
return(msr)
}
model_1_msr <- calculate_msr(model_1)
model_2_msr <- calculate_msr(model_2)
model_3_msr <- calculate_msr(model_3)
model_4_msr <- calculate_msr(model_4)
model_1
model_4
str(model_4)
resid
betas <- matrix(data = c(0.5, 2.0, .25), nrow = 3)
beta
betas
model.matrix(model_1)
model_1_predictions <- X %*% betas
betas <- matrix(data = c(0.5, 2.0, .25), nrow = 3)
X     <- model.matrix(model_1)
model_1_predictions <- X %*% betas
model_1_residuals
betas <- matrix(data = c(0.5, 2.0, .25), nrow = 3)
X     <- model.matrix(model_1)
model_1_predictions <- X %*% betas
model_1_residuals   <- d$y - model_1_predictions
model_1_residuals
model_1_residuals^2
model_1_residuals^2
model_1_msr_by_hand
betas <- matrix(data = c(0.5, 2.0, .25), nrow = 3)
X     <- model.matrix(model_1)
model_1_predictions <- X %*% betas
model_1_residuals   <- d$y - model_1_predictions
model_1_msr_by_hand <- mean(model_1_residuals^2)
model_1_msr_by_hand
model_1_msr_by_hand <- mean(model_1_residuals^2)
model_1_msr
model_1_msr_by_hand <- mean(model_1_residuals^2)
model_1_msr
betas <- matrix(data = c(0.5, 2.0, .25), nrow = 3)
X     <- model.matrix(model_1)
model_1_predictions <- X %*% betas
model_1_residuals   <- d$y - model_1_predictions
model_1_msr_by_hand <- mean(model_1_residuals^2)
model_1_msr_by_hand
model_1_msr
model.matrix(model_4)
betas <- matrix(data = c(0.5, 1, 2.0, .25), nrow = 3)
X     <- model.matrix(model_4)
betas <- matrix(data = c(0.5, 1, 2.0, .25), nrow = 3)
X     <- model.matrix(model_4)
model_4_predictions <- X %*% betas
betas <- matrix(data = c(0.5, 1, 2.0, .25), nrow = 4)
X     <- model.matrix(model_4)
model_4_predictions <- X %*% betas
model_4_residuals   <- d$y - model_1_predictions
model_4_msr_by_hand <- mean(model_1_residuals^2)
model_4_msr_by_hand
model_4_msr
model_4
library(dplyr)
library(broom)
library(ggplot2)
library(patchwork)
library(sandwich)
library(lmtest)
create_homoskedastic_data <- function(n = 100) {
d <- data.frame(id = 1:n) %>%
mutate(
x1 = runif(n=n, min=0, max=10),
x2 = rnorm(n=n, mean=10, sd=2),
x3 = rnorm(n=n, mean=0, sd=2),
y  = .5 + 1*x1 + 2*x2 + .25*x3^2 + rnorm(n=n, mean=0, sd=1)
)
return(d)
}
d <- create_homoskedastic_data(n=100)
outcome_histogram <- d %>%
ggplot() + # fill in the rest of this chunk to create a plot
aes(x = y) +
geom_histogram(bins = 20) +
labs(
x = "Outcome Values",
title = "Histogram of Outcomes",
subtitle = "It looks like the CLT should work."
)
outcome_histogram
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + x3, data = d)
model_3 <- lm(y ~ x1 + x2 + I(x3^2), data = d)
model_4 <- lm(y ~ x1 + x2 + x2 + I(x3^2), data = d)
calculate_msr <- function(model) {
# This function takes a model, and uses the `resid` function
# together with the definition of the msr to produce
# the MEAN of the squared residuals
msr <- mean(resid(model)^2)
return(msr)
}
model_1_msr <- calculate_msr(model_1)
model_2_msr <- calculate_msr(model_2)
model_3_msr <- calculate_msr(model_3)
model_4_msr <- calculate_msr(model_4)
betas <- matrix(data = c(0.5, 1, 2.0, .25), nrow = 4)
X     <- model.matrix(model_4)
model_4_predictions <- X %*% betas
model_4_residuals   <- d$y - model_1_predictions
model_4_msr_by_hand <- mean(model_1_residuals^2)
model_4_msr_by_hand
model_4_msr
model_4
betas <- matrix(data = c(0.25, 1, 2.0, .25), nrow = 4)
X     <- model.matrix(model_4)
model_4_predictions <- X %*% betas
model_4_residuals   <- d$y - model_1_predictions
model_4_msr_by_hand <- mean(model_1_residuals^2)
model_4_msr_by_hand
model_4_msr
model_4
betas <- matrix(data = c(0.25, 1, 2.0, .25), nrow = 4)
X     <- model.matrix(model_4)
model_4_predictions <- X %*% betas
model_4_residuals   <- d$y - model_4_predictions
model_4_msr_by_hand <- mean(model_4_residuals^2)
model_4_msr_by_hand
model_4_msr
betas <- matrix(data = c(0.5, 1, 2.0, .25), nrow = 4)
X     <- model.matrix(model_4)
model_4_predictions <- X %*% betas
model_4_residuals   <- d$y - model_4_predictions
model_4_msr_by_hand <- mean(model_4_residuals^2)
model_4_msr_by_hand
model_4_msr
model_4_msr_by_hand
model_4_msr
model_4_msr
model_1_msr
model_2_msr
model_3_msr
model_4_msr
model_2_msr
model_3_msr
model_4_msr
anova(model_4, model_1, test = 'F')
anova(model_4, model_3, test = 'F')
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + x3, data = d)
model_3 <- lm(y ~ x1 + x2 + I(x3^2), data = d)
model_4 <- lm(y ~ x1 + x2 + x3 + I(x3^2), data = d)
anova(model_4, model_3, test = 'F')
summary(model_2)
anova(model_2, model_1, test = 'F')
anova(model_1, model_2, test = 'F')
short_model <- lm(rem_any ~ 1, data = d[d$country == 3,])
library(dplyr)
library(broom)
library(ggplot2)
library(patchwork)
library(sandwich)
library(lmtest)
create_homoskedastic_data <- function(n = 100) {
d <- data.frame(id = 1:n) %>%
mutate(
x1 = runif(n=n, min=0, max=10),
x2 = rnorm(n=n, mean=10, sd=2),
x3 = rnorm(n=n, mean=0, sd=2),
y  = .5 + 1*x1 + 2*x2 + .25*x3^2 + rnorm(n=n, mean=0, sd=1)
)
return(d)
}
d <- create_homoskedastic_data(n=100)
outcome_histogram <- d %>%
ggplot() + # fill in the rest of this chunk to create a plot
aes(x = y) +
geom_histogram(bins = 20) +
labs(
x = "Outcome Values",
title = "Histogram of Outcomes",
subtitle = "It looks like the CLT should work."
)
outcome_histogram
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + x3, data = d)
model_3 <- lm(y ~ x1 + x2 + I(x3^2), data = d)
model_4 <- lm(y ~ x1 + x2 + x3 + I(x3^2), data = d)
calculate_msr <- function(model) {
# This function takes a model, and uses the `resid` function
# together with the definition of the msr to produce
# the MEAN of the squared residuals
msr <- mean(resid(model)^2)
return(msr)
}
model_1_msr <- calculate_msr(model_1)
model_2_msr <- calculate_msr(model_2)
model_3_msr <- calculate_msr(model_3)
model_4_msr <- calculate_msr(model_4)
betas <- matrix(data = c(0.5, 1, 2.0, .25), nrow = 4) # create coefficients vector
X     <- model.matrix(model_4)                        # pull matrix of data
#
model_4_predictions <- X %*% betas                    # produce predictions using matrix multiplication
short_model <- lm(rem_any ~ 1, data = d[d$country == 3,])
d
head(d)
d <- haven::read_dta(file = './karlan_data/analysis_dataallcountries.dta')
glimpse(d)
short_model <- lm(rem_any ~ 1, data = d[d$country == 3,])
long_model  <- lm(
rem_any ~ female + age + highschool_completed + wealthy +
married + inc_7d + hyperbolic + spent_b4isaved + saved_asmuch +
missing_female + missing_age + missing_highschool_completed + missing_wealthy +
missing_married + missing_inc_7d + missing_hyperbolic + missing_spent_b4isaved + missing_saved_as_much,
data = d[d$country == 3,])
short_model <- lm(rem_any ~ 1, data = d[d$country == 3,])
long_model  <- lm(
rem_any ~ female + age + highschool_completed + wealthy +
married + inc_7d + hyperbolic + spent_b4isaved + saved_asmuch +
missing_female + missing_age + missing_highschool_completed + missing_wealthy +
missing_married + missing_inc_7d + missing_hyperbolic + missing_spent_b4isaved + missing_saved_asmuch,
data = d[d$country == 3,])
anova(long_model, short_model, test = 'F')
model_pooled_no_covariates <- lm(
reached_b4goal ~ rem_any + highint + rewardint + joint +
dc + joint_single + factor(country),
data = d)
model_pooled_with_covariates <- lm(
reached_b4goal ~ rem_any + highint + rewardint + joint +
dc + joint_single +
female + age + highschool_completed + wealthy + married +
saved_formal + inc_7d + saved_asmuch + spent_b4isaved +
missing_female + missing_age + missing_highschool_completed +
missing_married +  missing_saved_asmuch + missing_spent_b4isaved +
factor(depart) + factor(provincia) + factor(marketer) + factor(branch) +
factor(country),
data = d)
stargazer::stargazer(
model_pooled_with_covariates, model_pooled_no_covariates,
omit = c('depart', 'provincia', 'marketer', 'branch', 'country'),
omit.labels = c(
'Department Fixed Effects', 'Province Fixed Effects',
'Marketer Fixed Effects',   'Branch Fixed Effects',
'Country Fixed Effects'),
single.row = TRUE,
type = 'latex')
stargazer::stargazer(
model_pooled_with_covariates, model_pooled_no_covariates,
omit = c('depart', 'provincia', 'marketer', 'branch', 'country'),
omit.labels = c(
'Department Fixed Effects', 'Province Fixed Effects',
'Marketer Fixed Effects',   'Branch Fixed Effects',
'Country Fixed Effects'),
single.row = TRUE,
type = 'latex',
header = FALSE,
title = 'Replication of Table 4')
calculate_msr(model_pooled_no_covariates)
calculate_msr(model_pooled_with_covariates)
anova(model_pooled_with_covariates, model_pooled_no_covariates, test = 'F')
The mean squared residuals of the short model are, **`r mean_squared_residual_no_covariates`**. The mean squared residuals of the long model are **`r mean_squared_residual_with_covariates`**. In the next chunk, we test whether the MSRs of the models are different using an F-test.
The mean squared residuals of the short model are, **`r mean_squared_residual_no_covariates`**. The mean squared residuals of the long model are **`r mean_squared_residual_with_covariates`**. In the next chunk, we test whether the MSRs of the models are different using an F-test.
The mean squared residuals of the short model are, **`r mean_squared_residual_no_covariates`**. The mean squared residuals of the long model are **`r mean_squared_residual_with_covariates`**. In the next chunk, we test whether the MSRs of the models are different using an F-test.
##coeftest(model_pooled_no_covariates, vcov. = vcovHC(model_pooled_no_covariates, type = 'HC1'))
coeftest(model_pooled_with_covariates, vcov. = vcovHC(model_pooled_with_covariates, type = 'HC1'))[1:16,]
library(dplyr)
library(broom)
library(ggplot2)
library(patchwork)
library(sandwich)
library(lmtest)
create_homoskedastic_data <- function(n = 100) {
d <- data.frame(id = 1:n) %>%
mutate(
x1 = runif(n=n, min=0, max=10),
x2 = rnorm(n=n, mean=10, sd=2),
x3 = rnorm(n=n, mean=0, sd=2),
y  = .5 + 1*x1 + 2*x2 + .25*x3^2 + rnorm(n=n, mean=0, sd=1)
)
return(d)
}
d <- create_homoskedastic_data(n=100)
outcome_histogram <- d %>%
ggplot() + # fill in the rest of this chunk to create a plot
aes(x = y) +
geom_histogram(bins = 20) +
labs(
x = "Outcome Values",
title = "Histogram of Outcomes",
subtitle = "It looks like the CLT should work."
)
outcome_histogram
# if you want to read about specifying statistical models, you can read
# here: https://cran.r-project.org/doc/manuals/R-intro.html#Formulae-for-statistical-models'
# note, using the I() function is preferred over using poly()
model_1 <- lm(y ~ x1 + x3     , data = d)
model_2 <- lm(y ~ x1 + x2 + x3, data = d)
model_3 <- lm(y ~ x1 + x2 + I(x3^2), data = d)
model_4 <- lm(y ~ x1 + x2 + x3 + I(x3^2), data = d)
calculate_msr <- function(model) {
# This function takes a model, and uses the `resid` function
# together with the definition of the msr to produce
# the MEAN of the squared residuals
msr <- mean(resid(model)^2)
return(msr)
}
model_1_msr <- calculate_msr(model_1)
model_2_msr <- calculate_msr(model_2)
model_3_msr <- calculate_msr(model_3)
model_4_msr <- calculate_msr(model_4)
model.matrix(model_4)                        # pull matrix of data
betas <- matrix(data = c(0.5, 1, 2.0, 0.0, .25), nrow = 4) # create coefficients vector
X     <- model.matrix(model_4)                        # pull matrix of data
#
model_4_predictions <- X %*% betas                    # produce predictions using matrix multiplication
betas <- matrix(data = c(0.5, 1, 2.0, 0.0, .25), nrow = 5) # create coefficients vector
X     <- model.matrix(model_4)                        # pull matrix of data
#
model_4_predictions <- X %*% betas                    # produce predictions using matrix multiplication
model_4_residuals   <- d$y - model_4_predictions      # residuals are differences between truth and prediction
model_4_msr_by_hand <- mean(model_4_residuals^2)      # literally mean of residuals squared
theme_set(theme_minimal())
options(digits = 3)
source(file = 'src/blank_lines.R')
getwd()
bookdown::render_book()
bookdown::render_book()
bookdown::render_book()
knitr::is_latex_output()
knitr::is_html_output()
bookdown::render_book()
bookdown::render_book()
bookdown::render_book(output_format = 'pdf_document')
?bookdown::render_book()
bookdown::render_book(output_format = 'pdf_document')
bookdown::render_book(output_format = 'pdf_document')
library(ggplot2)
source(file = 'src/blank_lines.R')
theme_set(theme_minimal())
knitr::knit_engines$set(notes = function(options) {
code <- paste(options$code, collapse = "\n")
})
ggplot() +
geom_blank() +
labs(
title = 'Joint PDF of X,Y',
x = 'x axis',
y = latex2exp::TeX('$P_{X,Y}(x,y)$')
)
ggplot() +
geom_blank() +
labs(
title = 'Joint PDF of X,Y',
x = 'x axis',
y = latex2exp::TeX('$P_{X,Y}(x,y)$')) +
theme_bw()
ggplot() +
geom_blank() +
labs(
title = 'Joint PDF of X,Y',
x = 'x axis',
y = latex2exp::TeX('$P_{X,Y}(x,y)$')) +
theme_light()
getwd()
bookdown::render_book(output_format = 'pdf_book')
?bookdown::pdf_book()
bookdown::render_book(output_format = 'pdf_book(keep_tex = TRUE)')
bookdown::render_book(output_format = 'bookdown::pdf_book(keep_tex = TRUE)')
bookdown::render_book(output_format = 'pdf_book')
bookdown::render_book(output_format = pdf_book)
?bookdown::render_book()
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::html_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::pdf_book')
bookdown::render_book(output_format = 'bookdown::html_book')
bookdown::render_book(output_format = 'bookdown::html_book')
bookdown::render_book(output_format = 'bookdown::html_book')
bookdown::render_book(output_format = 'bookdown::html_book')
